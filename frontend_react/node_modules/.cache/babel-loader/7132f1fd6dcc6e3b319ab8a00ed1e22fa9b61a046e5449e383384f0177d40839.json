{"ast":null,"code":"import _classCallCheck from \"D:/myportfolio/frontend_react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/myportfolio/frontend_react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { processOptions, validateOptions } from './_chunks/defaultOptionsValidator-4ba94809.js';\nimport parseHeaders from 'parse-headers';\nvar middlewareReducer = function middlewareReducer(middleware) {\n  var applyMiddleware = function applyMiddleware(hook, defaultValue) {\n    var bailEarly = hook === \"onError\";\n    var value = defaultValue;\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    for (var i = 0; i < middleware[hook].length; i++) {\n      var handler = middleware[hook][i];\n      value = handler.apply(void 0, [value].concat(args));\n      if (bailEarly && !value) {\n        break;\n      }\n    }\n    return value;\n  };\n  return applyMiddleware;\n};\nfunction createPubSub() {\n  var subscribers = /* @__PURE__ */Object.create(null);\n  var nextId = 0;\n  function subscribe(subscriber) {\n    var id = nextId++;\n    subscribers[id] = subscriber;\n    return function unsubscribe() {\n      delete subscribers[id];\n    };\n  }\n  function publish(event) {\n    for (var id in subscribers) {\n      subscribers[id](event);\n    }\n  }\n  return {\n    publish: publish,\n    subscribe: subscribe\n  };\n}\nvar channelNames = [\"request\", \"response\", \"progress\", \"error\", \"abort\"];\nvar middlehooks = [\"processOptions\", \"validateOptions\", \"interceptRequest\", \"finalizeOptions\", \"onRequest\", \"onResponse\", \"onError\", \"onReturn\", \"onHeaders\"];\nfunction createRequester(initMiddleware, httpRequest) {\n  var loadedMiddleware = [];\n  var middleware = middlehooks.reduce(function (ware, name) {\n    ware[name] = ware[name] || [];\n    return ware;\n  }, {\n    processOptions: [processOptions],\n    validateOptions: [validateOptions]\n  });\n  function request(opts) {\n    var channels = channelNames.reduce(function (target, name) {\n      target[name] = createPubSub();\n      return target;\n    }, {});\n    var applyMiddleware = middlewareReducer(middleware);\n    var options = applyMiddleware(\"processOptions\", opts);\n    applyMiddleware(\"validateOptions\", options);\n    var context = {\n      options: options,\n      channels: channels,\n      applyMiddleware: applyMiddleware\n    };\n    var ongoingRequest = null;\n    var unsubscribe = channels.request.subscribe(function (ctx) {\n      ongoingRequest = httpRequest(ctx, function (err, res) {\n        return onResponse(err, res, ctx);\n      });\n    });\n    channels.abort.subscribe(function () {\n      unsubscribe();\n      if (ongoingRequest) {\n        ongoingRequest.abort();\n      }\n    });\n    var returnValue = applyMiddleware(\"onReturn\", channels, context);\n    if (returnValue === channels) {\n      channels.request.publish(context);\n    }\n    return returnValue;\n    function onResponse(reqErr, res, ctx) {\n      var error = reqErr;\n      var response = res;\n      if (!error) {\n        try {\n          response = applyMiddleware(\"onResponse\", res, ctx);\n        } catch (err) {\n          response = null;\n          error = err;\n        }\n      }\n      error = error && applyMiddleware(\"onError\", error, ctx);\n      if (error) {\n        channels.error.publish(error);\n      } else if (response) {\n        channels.response.publish(response);\n      }\n    }\n  }\n  request.use = function use(newMiddleware) {\n    if (!newMiddleware) {\n      throw new Error(\"Tried to add middleware that resolved to falsey value\");\n    }\n    if (typeof newMiddleware === \"function\") {\n      throw new Error(\"Tried to add middleware that was a function. It probably expects you to pass options to it.\");\n    }\n    if (newMiddleware.onReturn && middleware.onReturn.length > 0) {\n      throw new Error(\"Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event\");\n    }\n    middlehooks.forEach(function (key) {\n      if (newMiddleware[key]) {\n        middleware[key].push(newMiddleware[key]);\n      }\n    });\n    loadedMiddleware.push(newMiddleware);\n    return request;\n  };\n  request.clone = function clone() {\n    return createRequester(loadedMiddleware, httpRequest);\n  };\n  initMiddleware.forEach(request.use);\n  return request;\n}\nvar __accessCheck = function __accessCheck(obj, member, msg) {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = function __privateGet(obj, member, getter) {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = function __privateAdd(obj, member, value) {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = function __privateSet(obj, member, value, setter) {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _method, _url, _resHeaders, _headers, _controller;\nvar FetchXhr = /*#__PURE__*/function () {\n  function FetchXhr() {\n    _classCallCheck(this, FetchXhr);\n    /**\n     * https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState\n     */\n    this.readyState = 0;\n    this.responseType = \"\";\n    /**\n     * Private implementation details\n     */\n    __privateAdd(this, _method, void 0);\n    __privateAdd(this, _url, void 0);\n    __privateAdd(this, _resHeaders, void 0);\n    __privateAdd(this, _headers, {});\n    __privateAdd(this, _controller, void 0);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- _async is only declared for typings compatibility\n  _createClass(FetchXhr, [{\n    key: \"open\",\n    value: function open(method, url, _async) {\n      __privateSet(this, _method, method);\n      __privateSet(this, _url, url);\n      __privateSet(this, _resHeaders, \"\");\n      this.readyState = 1;\n      this.onreadystatechange();\n      __privateSet(this, _controller, void 0);\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      if (__privateGet(this, _controller)) {\n        __privateGet(this, _controller).abort();\n      }\n    }\n  }, {\n    key: \"getAllResponseHeaders\",\n    value: function getAllResponseHeaders() {\n      return __privateGet(this, _resHeaders);\n    }\n  }, {\n    key: \"setRequestHeader\",\n    value: function setRequestHeader(name, value) {\n      __privateGet(this, _headers)[name] = value;\n    }\n  }, {\n    key: \"send\",\n    value: function send(body) {\n      var _this = this;\n      var textBody = this.responseType !== \"arraybuffer\";\n      var options = {\n        method: __privateGet(this, _method),\n        headers: __privateGet(this, _headers),\n        body: body\n      };\n      if (typeof AbortController === \"function\") {\n        __privateSet(this, _controller, new AbortController());\n        if (typeof EventTarget !== \"undefined\" && __privateGet(this, _controller).signal instanceof EventTarget) {\n          options.signal = __privateGet(this, _controller).signal;\n        }\n      }\n      if (typeof document !== \"undefined\") {\n        options.credentials = this.withCredentials ? \"include\" : \"omit\";\n      }\n      fetch(__privateGet(this, _url), options).then(function (res) {\n        res.headers.forEach(function (value, key) {\n          __privateSet(_this, _resHeaders, __privateGet(_this, _resHeaders) + \"\".concat(key, \": \").concat(value, \"\\r\\n\"));\n        });\n        _this.status = res.status;\n        _this.statusText = res.statusText;\n        _this.readyState = 3;\n        return textBody ? res.text() : res.arrayBuffer();\n      }).then(function (resBody) {\n        if (typeof resBody === \"string\") {\n          _this.responseText = resBody;\n        } else {\n          _this.response = resBody;\n        }\n        _this.readyState = 4;\n        _this.onreadystatechange();\n      }).catch(function (err) {\n        var _a;\n        if (err.name === \"AbortError\") {\n          _this.onabort();\n          return;\n        }\n        (_a = _this.onerror) == null ? void 0 : _a.call(_this, err);\n      });\n    }\n  }]);\n  return FetchXhr;\n}();\n_method = new WeakMap();\n_url = new WeakMap();\n_resHeaders = new WeakMap();\n_headers = new WeakMap();\n_controller = new WeakMap();\nvar adapter = typeof XMLHttpRequest === \"function\" ? \"xhr\" : \"fetch\";\nvar XmlHttpRequest = adapter === \"xhr\" ? XMLHttpRequest : FetchXhr;\nvar httpRequester = function httpRequester(context, callback) {\n  var opts = context.options;\n  var options = context.applyMiddleware(\"finalizeOptions\", opts);\n  var timers = {};\n  var injectedResponse = context.applyMiddleware(\"interceptRequest\", void 0, {\n    adapter: adapter,\n    context: context\n  });\n  if (injectedResponse) {\n    var cbTimer = setTimeout(callback, 0, null, injectedResponse);\n    var cancel = function cancel() {\n      return clearTimeout(cbTimer);\n    };\n    return {\n      abort: cancel\n    };\n  }\n  var xhr = new XmlHttpRequest();\n  var headers = options.headers;\n  var delays = options.timeout;\n  var aborted = false;\n  var loaded = false;\n  var timedOut = false;\n  xhr.onerror = function (event) {\n    onError(new Error(\"Request error while attempting to reach \".concat(options.url).concat(event.lengthComputable ? \"(\".concat(event.loaded, \" of \").concat(event.total, \" bytes transferred)\") : \"\")));\n  };\n  xhr.ontimeout = function (event) {\n    onError(new Error(\"Request timeout while attempting to reach \".concat(options.url).concat(event.lengthComputable ? \"(\".concat(event.loaded, \" of \").concat(event.total, \" bytes transferred)\") : \"\")));\n  };\n  xhr.onabort = function () {\n    stopTimers(true);\n    aborted = true;\n  };\n  xhr.onreadystatechange = function () {\n    resetTimers();\n    if (aborted || xhr.readyState !== 4) {\n      return;\n    }\n    if (xhr.status === 0) {\n      return;\n    }\n    onLoad();\n  };\n  xhr.open(options.method, options.url, true\n  // Always async\n  );\n\n  xhr.withCredentials = !!options.withCredentials;\n  if (headers && xhr.setRequestHeader) {\n    for (var key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n  }\n  if (options.rawBody) {\n    xhr.responseType = \"arraybuffer\";\n  }\n  context.applyMiddleware(\"onRequest\", {\n    options: options,\n    adapter: adapter,\n    request: xhr,\n    context: context\n  });\n  xhr.send(options.body || null);\n  if (delays) {\n    timers.connect = setTimeout(function () {\n      return timeoutRequest(\"ETIMEDOUT\");\n    }, delays.connect);\n  }\n  return {\n    abort: abort\n  };\n  function abort() {\n    aborted = true;\n    if (xhr) {\n      xhr.abort();\n    }\n  }\n  function timeoutRequest(code) {\n    timedOut = true;\n    xhr.abort();\n    var error = new Error(code === \"ESOCKETTIMEDOUT\" ? \"Socket timed out on request to \".concat(options.url) : \"Connection timed out on request to \".concat(options.url));\n    error.code = code;\n    context.channels.error.publish(error);\n  }\n  function resetTimers() {\n    if (!delays) {\n      return;\n    }\n    stopTimers();\n    timers.socket = setTimeout(function () {\n      return timeoutRequest(\"ESOCKETTIMEDOUT\");\n    }, delays.socket);\n  }\n  function stopTimers(force) {\n    if (force || aborted || xhr.readyState >= 2 && timers.connect) {\n      clearTimeout(timers.connect);\n    }\n    if (timers.socket) {\n      clearTimeout(timers.socket);\n    }\n  }\n  function onError(error) {\n    if (loaded) {\n      return;\n    }\n    stopTimers(true);\n    loaded = true;\n    xhr = null;\n    var err = error || new Error(\"Network error while attempting to reach \".concat(options.url));\n    err.isNetworkError = true;\n    err.request = options;\n    callback(err);\n  }\n  function reduceResponse() {\n    return {\n      body: xhr.response || (xhr.responseType === \"\" || xhr.responseType === \"text\" ? xhr.responseText : \"\"),\n      url: options.url,\n      method: options.method,\n      headers: parseHeaders(xhr.getAllResponseHeaders()),\n      statusCode: xhr.status,\n      statusMessage: xhr.statusText\n    };\n  }\n  function onLoad() {\n    if (aborted || loaded || timedOut) {\n      return;\n    }\n    if (xhr.status === 0) {\n      onError(new Error(\"Unknown XHR error\"));\n      return;\n    }\n    stopTimers();\n    loaded = true;\n    callback(null, reduceResponse());\n  }\n};\nvar getIt = function getIt() {\n  var initMiddleware = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var httpRequest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : httpRequester;\n  return createRequester(initMiddleware, httpRequest);\n};\nvar environment = \"browser\";\nexport { adapter, environment, getIt };","map":{"version":3,"names":["middlewareReducer","middleware","applyMiddleware","hook","defaultValue","bailEarly","value","_len","arguments","length","args","Array","_key","i","handler","apply","concat","createPubSub","subscribers","Object","create","nextId","subscribe","subscriber","id","unsubscribe","publish","event","channelNames","middlehooks","createRequester","initMiddleware","httpRequest","loadedMiddleware","reduce","ware","name","processOptions","validateOptions","request","opts","channels","target","options","context","ongoingRequest","ctx","err","res","onResponse","abort","returnValue","reqErr","error","response","use","newMiddleware","Error","onReturn","forEach","key","push","clone","_method","_url","_resHeaders","_headers","_controller","FetchXhr","_classCallCheck","readyState","responseType","__privateAdd","_createClass","open","method","url","_async","__privateSet","onreadystatechange","__privateGet","getAllResponseHeaders","setRequestHeader","send","body","_this","textBody","headers","AbortController","EventTarget","signal","document","credentials","withCredentials","fetch","then","status","statusText","text","arrayBuffer","resBody","responseText","catch","_a","onabort","onerror","call","WeakMap","adapter","XMLHttpRequest","XmlHttpRequest","httpRequester","callback","timers","injectedResponse","cbTimer","setTimeout","cancel","clearTimeout","xhr","delays","timeout","aborted","loaded","timedOut","onError","lengthComputable","total","ontimeout","stopTimers","resetTimers","onLoad","hasOwnProperty","rawBody","connect","timeoutRequest","code","socket","force","isNetworkError","reduceResponse","parseHeaders","statusCode","statusMessage","getIt","undefined","environment"],"sources":["D:\\myportfolio\\frontend_react\\node_modules\\get-it\\src\\util\\middlewareReducer.ts","D:\\myportfolio\\frontend_react\\node_modules\\get-it\\src\\util\\pubsub.ts","D:\\myportfolio\\frontend_react\\node_modules\\get-it\\src\\createRequester.ts","D:\\myportfolio\\frontend_react\\node_modules\\get-it\\src\\request\\browser\\fetchXhr.ts","D:\\myportfolio\\frontend_react\\node_modules\\get-it\\src\\request\\browser-request.ts","D:\\myportfolio\\frontend_react\\node_modules\\get-it\\src\\index.browser.ts"],"sourcesContent":["export default (middleware: any) => {\n  const applyMiddleware = (hook: any, defaultValue: any, ...args: any[]) => {\n    const bailEarly = hook === 'onError'\n\n    let value = defaultValue\n    for (let i = 0; i < middleware[hook].length; i++) {\n      const handler = middleware[hook][i]\n      value = handler(value, ...args)\n\n      if (bailEarly && !value) {\n        break\n      }\n    }\n\n    return value\n  }\n\n  return applyMiddleware\n}\n","// Code borrowed from https://github.com/bjoerge/nano-pubsub\n\nexport interface Subscriber<Event> {\n  (event: Event): void\n}\nexport interface PubSub<Message> {\n  publish: (message: Message) => void\n  subscribe: (subscriber: Subscriber<Message>) => () => void\n}\n\nexport function createPubSub<Message = void>(): PubSub<Message> {\n  const subscribers: {[id: string]: Subscriber<Message>} = Object.create(null)\n  let nextId = 0\n  function subscribe(subscriber: Subscriber<Message>) {\n    const id = nextId++\n    subscribers[id] = subscriber\n    return function unsubscribe() {\n      delete subscribers[id]\n    }\n  }\n\n  function publish(event: Message) {\n    for (const id in subscribers) {\n      subscribers[id](event)\n    }\n  }\n\n  return {\n    publish,\n    subscribe,\n  }\n}\n","import {processOptions} from './middleware/defaultOptionsProcessor'\nimport {validateOptions} from './middleware/defaultOptionsValidator'\nimport type {HttpRequest, Middleware, Middlewares, Requester} from './types'\nimport middlewareReducer from './util/middlewareReducer'\nimport {createPubSub} from './util/pubsub'\n\nconst channelNames = ['request', 'response', 'progress', 'error', 'abort']\nconst middlehooks = [\n  'processOptions',\n  'validateOptions',\n  'interceptRequest',\n  'finalizeOptions',\n  'onRequest',\n  'onResponse',\n  'onError',\n  'onReturn',\n  'onHeaders',\n]\n\n/** @public */\nexport function createRequester(initMiddleware: Middlewares, httpRequest: HttpRequest): Requester {\n  const loadedMiddleware: any[] = []\n  const middleware = middlehooks.reduce(\n    (ware: any, name: any) => {\n      ware[name] = ware[name] || []\n      return ware\n    },\n    {\n      processOptions: [processOptions],\n      validateOptions: [validateOptions],\n    }\n  )\n\n  function request(opts: any) {\n    const channels = channelNames.reduce((target: any, name: any): any => {\n      target[name] = createPubSub()\n      return target\n    }, {})\n\n    // Prepare a middleware reducer that can be reused throughout the lifecycle\n    const applyMiddleware = middlewareReducer(middleware)\n\n    // Parse the passed options\n    const options = applyMiddleware('processOptions', opts)\n\n    // Validate the options\n    applyMiddleware('validateOptions', options)\n\n    // Build a context object we can pass to child handlers\n    const context = {options, channels, applyMiddleware}\n\n    // We need to hold a reference to the current, ongoing request,\n    // in order to allow cancellation. In the case of the retry middleware,\n    // a new request might be triggered\n    let ongoingRequest: any = null\n    const unsubscribe = channels.request.subscribe((ctx: any) => {\n      // Let request adapters (node/browser) perform the actual request\n      ongoingRequest = httpRequest(ctx, (err: any, res: any) => onResponse(err, res, ctx))\n    })\n\n    // If we abort the request, prevent further requests from happening,\n    // and be sure to cancel any ongoing request (obviously)\n    channels.abort.subscribe(() => {\n      unsubscribe()\n      if (ongoingRequest) {\n        ongoingRequest.abort()\n      }\n    })\n\n    // See if any middleware wants to modify the return value - for instance\n    // the promise or observable middlewares\n    const returnValue = applyMiddleware('onReturn', channels, context)\n\n    // If return value has been modified by a middleware, we expect the middleware\n    // to publish on the 'request' channel. If it hasn't been modified, we want to\n    // trigger it right away\n    if (returnValue === channels) {\n      channels.request.publish(context)\n    }\n\n    return returnValue\n\n    function onResponse(reqErr: any, res: any, ctx: any) {\n      let error = reqErr\n      let response = res\n\n      // We're processing non-errors first, in case a middleware converts the\n      // response into an error (for instance, status >= 400 == HttpError)\n      if (!error) {\n        try {\n          response = applyMiddleware('onResponse', res, ctx)\n        } catch (err) {\n          response = null\n          error = err\n        }\n      }\n\n      // Apply error middleware - if middleware return the same (or a different) error,\n      // publish as an error event. If we *don't* return an error, assume it has been handled\n      error = error && applyMiddleware('onError', error, ctx)\n\n      // Figure out if we should publish on error/response channels\n      if (error) {\n        channels.error.publish(error)\n      } else if (response) {\n        channels.response.publish(response)\n      }\n    }\n  }\n\n  request.use = function use(newMiddleware: Middleware) {\n    if (!newMiddleware) {\n      throw new Error('Tried to add middleware that resolved to falsey value')\n    }\n\n    if (typeof newMiddleware === 'function') {\n      throw new Error(\n        'Tried to add middleware that was a function. It probably expects you to pass options to it.'\n      )\n    }\n\n    if (newMiddleware.onReturn && middleware.onReturn.length > 0) {\n      throw new Error(\n        'Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event'\n      )\n    }\n\n    middlehooks.forEach((key) => {\n      if (newMiddleware[key]) {\n        middleware[key].push(newMiddleware[key])\n      }\n    })\n\n    loadedMiddleware.push(newMiddleware)\n    return request\n  }\n\n  request.clone = function clone() {\n    return createRequester(loadedMiddleware, httpRequest)\n  }\n\n  initMiddleware.forEach(request.use)\n\n  return request\n}\n","/**\n * Mimicks the XMLHttpRequest API with only the parts needed for get-it's XHR adapter\n */\nexport class FetchXhr\n  implements Pick<XMLHttpRequest, 'open' | 'abort' | 'getAllResponseHeaders' | 'setRequestHeader'>\n{\n  /**\n   * Public interface, interop with real XMLHttpRequest\n   */\n  onabort: () => void\n  onerror: (error?: any) => void\n  onreadystatechange: () => void\n  ontimeout: XMLHttpRequest['ontimeout']\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState\n   */\n  readyState: 0 | 1 | 2 | 3 | 4 = 0\n  response: XMLHttpRequest['response']\n  responseText: XMLHttpRequest['responseText']\n  responseType: XMLHttpRequest['responseType'] = ''\n  status: XMLHttpRequest['status']\n  statusText: XMLHttpRequest['statusText']\n  withCredentials: XMLHttpRequest['withCredentials']\n\n  /**\n   * Private implementation details\n   */\n  #method: string\n  #url: string\n  #resHeaders: string\n  #headers: Record<string, string> = {}\n  #controller?: AbortController\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- _async is only declared for typings compatibility\n  open(method: string, url: string, _async?: boolean) {\n    this.#method = method\n    this.#url = url\n    this.#resHeaders = ''\n    this.readyState = 1 // Open\n    this.onreadystatechange()\n    this.#controller = undefined\n  }\n  abort() {\n    if (this.#controller) {\n      this.#controller.abort()\n    }\n  }\n  getAllResponseHeaders() {\n    return this.#resHeaders\n  }\n  setRequestHeader(name: string, value: string) {\n    this.#headers[name] = value\n  }\n  send(body: BodyInit) {\n    const textBody = this.responseType !== 'arraybuffer'\n    const options: RequestInit = {\n      method: this.#method,\n      headers: this.#headers,\n      body,\n    }\n    if (typeof AbortController === 'function') {\n      this.#controller = new AbortController()\n      // The instanceof check ensures environments like Edge Runtime, Node 18 with built-in fetch\n      // and more don't throw if `signal` doesn't implement`EventTarget`\n      // Native browser AbortSignal implements EventTarget, so we can use it\n      if (typeof EventTarget !== 'undefined' && this.#controller.signal instanceof EventTarget) {\n        options.signal = this.#controller.signal\n      }\n    }\n\n    // Some environments (like CloudFlare workers) don't support credentials in\n    // RequestInitDict, and there doesn't seem to be any easy way to check for it,\n    // so for now let's just make do with a document check :/\n    if (typeof document !== 'undefined') {\n      options.credentials = this.withCredentials ? 'include' : 'omit'\n    }\n\n    fetch(this.#url, options)\n      .then((res): Promise<string | ArrayBuffer> => {\n        res.headers.forEach((value: any, key: any) => {\n          this.#resHeaders += `${key}: ${value}\\r\\n`\n        })\n        this.status = res.status\n        this.statusText = res.statusText\n        this.readyState = 3 // Loading\n        return textBody ? res.text() : res.arrayBuffer()\n      })\n      .then((resBody) => {\n        if (typeof resBody === 'string') {\n          this.responseText = resBody\n        } else {\n          this.response = resBody\n        }\n        this.readyState = 4 // Done\n        this.onreadystatechange()\n      })\n      .catch((err: Error) => {\n        if (err.name === 'AbortError') {\n          this.onabort()\n          return\n        }\n\n        this.onerror?.(err)\n      })\n  }\n}\n","import parseHeaders from 'parse-headers'\n\nimport type {RequestAdapter} from '../types'\nimport {FetchXhr} from './browser/fetchXhr'\n\n// Use fetch if it's available, non-browser environments such as Deno, Edge Runtime and more provide fetch as a global but doesn't provide xhr\nexport const adapter: RequestAdapter = typeof XMLHttpRequest === 'function' ? 'xhr' : 'fetch'\n\n// Fallback to fetch-based XHR polyfill for non-browser environments like Workers\nconst XmlHttpRequest = adapter === 'xhr' ? XMLHttpRequest : FetchXhr\n\nexport default (context: any, callback: (err: Error | null, response?: any) => void) => {\n  const opts = context.options\n  const options = context.applyMiddleware('finalizeOptions', opts)\n  const timers: any = {}\n\n  // Allow middleware to inject a response, for instance in the case of caching or mocking\n  const injectedResponse = context.applyMiddleware('interceptRequest', undefined, {\n    adapter,\n    context,\n  })\n\n  // If middleware injected a response, treat it as we normally would and return it\n  // Do note that the injected response has to be reduced to a cross-environment friendly response\n  if (injectedResponse) {\n    const cbTimer = setTimeout(callback, 0, null, injectedResponse)\n    const cancel = () => clearTimeout(cbTimer)\n    return {abort: cancel}\n  }\n\n  // We'll want to null out the request on success/failure\n  let xhr = new XmlHttpRequest()\n\n  const headers = options.headers\n  const delays = options.timeout\n\n  // Request state\n  let aborted = false\n  let loaded = false\n  let timedOut = false\n\n  // Apply event handlers\n  xhr.onerror = (event: ProgressEvent) => {\n    onError(\n      new Error(\n        `Request error while attempting to reach ${options.url}${\n          event.lengthComputable ? `(${event.loaded} of ${event.total} bytes transferred)` : ''\n        }`\n      )\n    )\n  }\n  xhr.ontimeout = (event: ProgressEvent) => {\n    onError(\n      new Error(\n        `Request timeout while attempting to reach ${options.url}${\n          event.lengthComputable ? `(${event.loaded} of ${event.total} bytes transferred)` : ''\n        }`\n      )\n    )\n  }\n  xhr.onabort = () => {\n    stopTimers(true)\n    aborted = true\n  }\n\n  xhr.onreadystatechange = () => {\n    // Prevent request from timing out\n    resetTimers()\n\n    if (aborted || xhr.readyState !== 4) {\n      return\n    }\n\n    // Will be handled by onError\n    if (xhr.status === 0) {\n      return\n    }\n\n    onLoad()\n  }\n\n  // @todo two last options to open() is username/password\n  xhr.open(\n    options.method,\n    options.url,\n    true // Always async\n  )\n\n  // Some options need to be applied after open\n  xhr.withCredentials = !!options.withCredentials\n\n  // Set headers\n  if (headers && xhr.setRequestHeader) {\n    for (const key in headers) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key])\n      }\n    }\n  }\n\n  if (options.rawBody) {\n    xhr.responseType = 'arraybuffer'\n  }\n\n  // Let middleware know we're about to do a request\n  context.applyMiddleware('onRequest', {options, adapter, request: xhr, context})\n\n  xhr.send(options.body || null)\n\n  // Figure out which timeouts to use (if any)\n  if (delays) {\n    timers.connect = setTimeout(() => timeoutRequest('ETIMEDOUT'), delays.connect)\n  }\n\n  return {abort}\n\n  function abort() {\n    aborted = true\n\n    if (xhr) {\n      xhr.abort()\n    }\n  }\n\n  function timeoutRequest(code: any) {\n    timedOut = true\n    xhr.abort()\n    const error: any = new Error(\n      code === 'ESOCKETTIMEDOUT'\n        ? `Socket timed out on request to ${options.url}`\n        : `Connection timed out on request to ${options.url}`\n    )\n    error.code = code\n    context.channels.error.publish(error)\n  }\n\n  function resetTimers() {\n    if (!delays) {\n      return\n    }\n\n    stopTimers()\n    timers.socket = setTimeout(() => timeoutRequest('ESOCKETTIMEDOUT'), delays.socket)\n  }\n\n  function stopTimers(force?: boolean) {\n    // Only clear the connect timeout if we've got a connection\n    if (force || aborted || (xhr.readyState >= 2 && timers.connect)) {\n      clearTimeout(timers.connect)\n    }\n\n    if (timers.socket) {\n      clearTimeout(timers.socket)\n    }\n  }\n\n  function onError(error: Error) {\n    if (loaded) {\n      return\n    }\n\n    // Clean up\n    stopTimers(true)\n    loaded = true\n    ;(xhr as any) = null\n\n    // Annoyingly, details are extremely scarce and hidden from us.\n    // We only really know that it is a network error\n    const err = (error ||\n      new Error(`Network error while attempting to reach ${options.url}`)) as Error & {\n      isNetworkError: boolean\n      request?: any\n    }\n    err.isNetworkError = true\n    err.request = options\n    callback(err)\n  }\n\n  function reduceResponse() {\n    return {\n      body:\n        xhr.response ||\n        (xhr.responseType === '' || xhr.responseType === 'text' ? xhr.responseText : ''),\n      url: options.url,\n      method: options.method,\n      headers: parseHeaders(xhr.getAllResponseHeaders()),\n      statusCode: xhr.status,\n      statusMessage: xhr.statusText,\n    }\n  }\n\n  function onLoad() {\n    if (aborted || loaded || timedOut) {\n      return\n    }\n\n    if (xhr.status === 0) {\n      onError(new Error('Unknown XHR error'))\n      return\n    }\n\n    // Prevent being called twice\n    stopTimers()\n    loaded = true\n    callback(null, reduceResponse())\n  }\n}\n","import {createRequester} from './createRequester'\nimport httpRequester from './request/browser-request'\nimport type {ExportEnv, HttpRequest, Middlewares, Requester} from './types'\n\nexport * from './types'\n\n/** @public */\nexport const getIt = (\n  initMiddleware: Middlewares = [],\n  httpRequest: HttpRequest = httpRequester\n): Requester => createRequester(initMiddleware, httpRequest)\n\n/** @public */\nexport const environment: ExportEnv = 'browser'\n\n/** @public */\nexport {adapter} from './request/browser-request'\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}